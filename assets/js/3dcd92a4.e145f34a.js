"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[29],{3107:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var n=i(4848),r=i(8453);const o={sidebar_position:2},s="Compiling to OT Circuits",a={id:"build/compiling-to-ot-circuits",title:"Compiling to OT Circuits",description:"Quilibrium utilizes Oblivious Transfer, a technique for providing garbled circuits that enable computation to confidentially and securely occur between two or more parties, as well as provide a substrate for proof creation and verification that the circuit's execution and outputs are correct for the application.",source:"@site/docs/build/compiling-to-ot-circuits.md",sourceDirName:"build",slug:"/build/compiling-to-ot-circuits",permalink:"/docs/build/compiling-to-ot-circuits",draft:!1,unlisted:!1,editUrl:"https://github.com/QuilibriumNetwork/docs/tree/main/docs/build/compiling-to-ot-circuits.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"build",previous:{title:"Running Applications",permalink:"/docs/build/running-applications"},next:{title:"Deploying to the Network",permalink:"/docs/build/deploying-to-the-network"}},c={},l=[{value:"Types",id:"types",level:2},{value:"RDF",id:"rdf",level:2},{value:"2PC vs MPC",id:"2pc-vs-mpc",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"compiling-to-ot-circuits",children:"Compiling to OT Circuits"})}),"\n",(0,n.jsx)(t.p,{children:"Quilibrium utilizes Oblivious Transfer, a technique for providing garbled circuits that enable computation to confidentially and securely occur between two or more parties, as well as provide a substrate for proof creation and verification that the circuit's execution and outputs are correct for the application."}),"\n",(0,n.jsxs)(t.p,{children:["Quilibrium utilizes a subset of golang, called Q Compute Language (QCL), and an associated compiler, Bedlam, for producing these circuits, as well as defining the schema of the data for serialization on the network, and any relationships the data may have over the ",(0,n.jsx)(t.a,{href:"/docs/learn/oblivious-hypergraph/rdf-storage",children:"oblivious hypergraph"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"types",children:"Types"}),"\n",(0,n.jsx)(t.p,{children:"The primary differences between QCL and golang are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Primitive types must have bounded sizes, e.g. int -> int8, int16, int32."}),"\n",(0,n.jsx)(t.li,{children:"Arrays must also have bounded sizes, e.g. []byte -> [8]byte."}),"\n",(0,n.jsx)(t.li,{children:"Stored types should have RDF schema tags."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Bedlam also has support for testing the evaluation of circuits without having to deploy the application to the network first, however this has limitations as there is no corresponding hypergraph to retrieve from or store to, and so the input references must be provided as the serialized data expected for the reference."}),"\n",(0,n.jsx)(t.h2,{id:"rdf",children:"RDF"}),"\n",(0,n.jsxs)(t.p,{children:["Structs that are stored on the hypergraph must have corresponding ",(0,n.jsx)(t.a,{href:"/docs/learn/oblivious-hypergraph/rdf-storage",children:"RDF"})," schema. Generally, it is easier to start from the RDF, and use the generated QCL types. As an example, we will define a simple RDF class holding 256 bytes, saving it to a file named ",(0,n.jsx)(t.code,{children:"byteblock.rdf"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'BASE <https://types.quilibrium.com/schema-repository/>\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX qcl: <https://types.quilibrium.com/qcl/>\nPREFIX byteblock: <https://types.quilibrium.com/schema-repository/examples/byteblock/>\n\nbyteblock:ByteBlock a rdfs:Class;\n  rdfs:label "an example RDF class".\nbyteblock:Bytes a rdfs:Property;\n  rdfs:domain qcl:ByteArray;\n  qcl:size 256;\n  qcl:order 0;\n  rdfs:range byteblock:ByteBlock.\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Running ",(0,n.jsx)(t.code,{children:"qclient schema qclgen byteblock.rdf"})," will return ",(0,n.jsx)(t.code,{children:"byteblock.qcl"}),", which contains the boilerplate hypergraph serialization implementations:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'package main\n\ntype ByteBlock struct {\n  Bytes [256]byte `rdf:"byteblock:Bytes"`\n}\n\nfunc UnmarshalByteBlock(payload [256]byte) ByteBlock {\n  result := ByteBlock{}\n  result.Bytes = payload[0:256]\n  return result\n}\n\nfunc MarshalByteBlock(obj ByteBlock) [256]byte {\n  buf := make([]byte, 256)\n  copy(buf[0:256], obj.ByteBlock)\n  return buf\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["From this you can add your ",(0,n.jsx)(t.code,{children:"main"})," entrypoint, which can emit ",(0,n.jsx)(t.code,{children:"hypergraph.CreateExtrinsic"}),", ",(0,n.jsx)(t.code,{children:"hypergraph.UpdateExtrinsic"}),", and ",(0,n.jsx)(t.code,{children:"hypergraph.DeleteExtrinsic"})," types related to storage operations of the defined struct."]}),"\n",(0,n.jsx)(t.h2,{id:"2pc-vs-mpc",children:"2PC vs MPC"}),"\n",(0,n.jsx)(t.p,{children:"While applications are 2PC by default, you may have a specific need to allow multiple parties outside of the requestor and a prover to jointly compute an application. QCL supports this with simple syntax. The main method entrypoint for your application takes at a minimum, an input argument by the initiator, and a relay argument for the base 2PC scenario:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"package main\n\nfunc main(input int8, relay hypergraph.Network) int8 {\n  return input + 2;\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"For MPC applications, you define the parties via additional arguments (omitting the relay argument):"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"package main\n\nfunc main(initiatorInput int8, secondInput int8) bool {\n  return initiatorInput > secondInput;\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Note: The hypergraph store types handle encryption and settlement of data, and return reference addresses. The return values in QCL are exposed to all participants as outputs."})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var n=i(6540);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);