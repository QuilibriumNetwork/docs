"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[115],{7973:(i,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=t(4848),o=t(8453);const a={sidebar_position:1},r="Running Applications",s={id:"build/running-applications",title:"Running Applications",description:"Interacting with applications on Quilibrium take different forms based on the architecture of the application and how it was deployed. While each application should provide their own documentation and tooling, there are certain basic properties that can be discovered for public applications.",source:"@site/docs/build/running-applications.md",sourceDirName:"build",slug:"/build/running-applications",permalink:"/docs/build/running-applications",draft:!1,unlisted:!1,editUrl:"https://github.com/QuilibriumNetwork/docs/tree/main/docs/build/running-applications.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"build",next:{title:"Compiling to OT Circuits",permalink:"/docs/build/compiling-to-ot-circuits"}},c={},l=[{value:"Simple QCL Applications",id:"simple-qcl-applications",level:2},{value:"Multi-Party QCL Applications",id:"multi-party-qcl-applications",level:2},{value:"Continuous Applications",id:"continuous-applications",level:2}];function p(i){const e={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...i.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.header,{children:(0,n.jsx)(e.h1,{id:"running-applications",children:"Running Applications"})}),"\n",(0,n.jsx)(e.p,{children:"Interacting with applications on Quilibrium take different forms based on the architecture of the application and how it was deployed. While each application should provide their own documentation and tooling, there are certain basic properties that can be discovered for public applications."}),"\n",(0,n.jsx)(e.h2,{id:"simple-qcl-applications",children:"Simple QCL Applications"}),"\n",(0,n.jsxs)(e.p,{children:["Interacting with a simple QCL Application is achieved via ",(0,n.jsx)(e.a,{href:"/docs/learn/oblivious-hypergraph/query-evaluator",children:"packed"})," messages on the network, and will vary based on whether the request is offline (already proven) or online (needs to be proven)."]}),"\n",(0,n.jsxs)(e.p,{children:["Given the application's address and referential inputs, the query evaluator picks up either the ",(0,n.jsx)(e.a,{href:"/docs/learn/communication/mixnet-routing",children:"rendezvous"})," request or offline request, and emits state updates (if relevant) with related ",(0,n.jsx)(e.a,{href:"/docs/learn/communication/e2ee",children:"dispatches"}),"."]}),"\n",(0,n.jsx)(e.h2,{id:"multi-party-qcl-applications",children:"Multi-Party QCL Applications"}),"\n",(0,n.jsx)(e.p,{children:"Given their very nature, multi-party QCL applications (denoted by taking multiple inputs on the function) will always require a rendezvous request. The initiator is expected to provide the rendezvous identifier to the additional parties, how this is conveyed is up to the application implementer, but a common approach is either via QR codes or NFC for mobile-to-mobile interactions, or via direct dispatches on the network."}),"\n",(0,n.jsx)(e.h2,{id:"continuous-applications",children:"Continuous Applications"}),"\n",(0,n.jsx)(e.p,{children:"Continuous applications are QCL Applications that have a scaffolding associated with chunked evaluation where distinct steps of the evaluation process occur over multiple frames on a core shard, similar to how a CPU core evaluates linear instructions in sequence over each cycle. To reduce the potential of linkability, a continuous application invocation initiates over a rendezvous request, which is retained open as a connection until the evaluation completes, with some amount of buffer to provide satisfactory privacy to the invoker."})]})}function d(i={}){const{wrapper:e}={...(0,o.R)(),...i.components};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(p,{...i})}):p(i)}},8453:(i,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var n=t(6540);const o={},a=n.createContext(o);function r(i){const e=n.useContext(a);return n.useMemo((function(){return"function"==typeof i?i(e):{...e,...i}}),[e,i])}function s(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:r(i.components),n.createElement(a.Provider,{value:e},i.children)}}}]);