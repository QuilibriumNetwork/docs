"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[356],{4845:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>p,frontMatter:()=>n,metadata:()=>c,toc:()=>d});var s=o(4848),i=o(8453),a=(o(6540),o(4625));const r=()=>(0,s.jsx)("div",{className:"learn-page text-left flex md:flex-row flex-col text-slate",children:(0,s.jsxs)("div",{className:"flex-1",children:[(0,s.jsxs)("p",{className:"pb-4 text-justify",children:["In ",(0,s.jsx)("a",{href:"https://eprint.iacr.org/2018/601.pdf",children:'"Verifiable Delay Functions"'}),", Boneh et. al. introduced a formalization of the behavior of what constitutes a verifiable delay function (VDF), along with some candidate functions. In short, the behavior of a VDF should satisfy three properties:"]}),(0,s.jsxs)("ol",{className:"list-decimal pl-6 text-justify",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Sequential"})," \u2013 The processing of the function is inherently non-parallelizable."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Efficiently Verifiable"})," \u2013 Verifying the proof output of evaluation must be sufficiently faster than calculating the proof itself."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("b",{children:"Unique"})," \u2013 It is computationally infeasible to find an output for a given input that collides with another output and proof."]})]}),(0,s.jsx)("p",{className:"pt-4 text-justify",children:"Many constructions of VDFs relate to the problem of squaring a number repeatedly under an algebraic group that is computationally infeasible to shortcut. In a related, earlier construction, Timelock puzzles utilized squaring under an RSA group, however knowledge of the prime factors was sufficient to calculate this efficiently, i.e. a proof of spending this quantity of time is reliant on a trusted setup. Additionally, it is not universally verifiable \u2013 the verifier must be aware of the secret state."}),(0,s.jsx)("h2",{className:"text-xl pt-10 pb-4 font-medium",children:"Wesolowski VDF"}),(0,s.jsxs)("p",{className:"pb-4 text-justify",children:["In ",(0,s.jsx)("a",{href:"https://eprint.iacr.org/2018/623",children:'"Efficient verifiable delay functions"'}),", by Benjamin Wesolowski, a construction based around imaginary quadratic cryptography is proposed. Under certain conditions, the class group of an imaginary quadratic field enables a construction of the aforementioned repeated-squaring approach, but is efficiently and universally verifiable."]}),(0,s.jsxs)("p",{className:"pb-4 text-justify",children:["Other networks have adopted the use of this VDF, such as Chia Network, and by consequence of their consensus mechanism being Nakamoto consensus using VDF as a unique proof of holding space over time, the network incentives were strongly aligned to the production of ASICs which implement this VDF as efficiently as possible. We thus have a very well-defined upper bound on the performance of this approach, and node operators wishing to provide as broad a collection of proofs have specialized hardware already meaningfully available to do so. To ensure this compatibility, we have adopted the classgroup arithmetic specified in ",(0,s.jsx)("a",{href:"https://sonnie.org/wp-content/uploads/2021/08/BinaryQuadraticForms.pdf",children:'"Binary quadratic forms"'})," by Lipa Long."]}),(0,s.jsx)("h2",{className:"text-xl pt-10 pb-4 font-medium",children:"Bootstrapping Ceremony"}),(0,s.jsxs)("p",{className:"pb-4 text-justify",children:["Using this VDF, the network initially bootstraps its master pulse clock input over the first hour of network runtime. When the network is first launched, operators will begin mesh construction following the processes of ",(0,s.jsx)(a.N_,{to:"/docs/learn/communication/p2p-communication",children:"BlossomSub"}),". Either after an hour is reached, or the network mesh remains sufficiently stabilized, whichever occurs first, the network will collectively perform a global ",(0,s.jsx)("a",{href:"https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf",children:"KZG"})," initialization ceremony, and toss the field element, publishing the public parameters. This will serve as the genesis input for the master pulse VDF."]}),(0,s.jsx)("h2",{className:"text-xl pt-10 pb-4 font-medium",children:"Consensus Intervals"}),(0,s.jsx)("p",{className:"pb-4 text-justify",children:"The VDF proofs are gossiped as a bundle every second to the network, serving as the heartbeat for BlossomSub, tagged with the current UTC time of the node creating the proof. Every hour thereafter, the network will evaluate the gossipped proofs against the global delta, as some machines will inherently emit at a slightly faster rate. The iteration count of the VDF is recalibrated to remain aligned to 10s intervals. Because there is no reward basis attached to computing the master pulse VDF, this recalibration process is not inherently tilted towards the fastest producers, but rather the mean. This is so that VDF proof generation built around ASICs is favored for block storage proofs instead."}),(0,s.jsx)("h2",{className:"text-xl pt-10 pb-4 font-medium",children:"Relationship to Block Storage"}),(0,s.jsx)("p",{className:"pb-4 text-justify",children:"To utilize the VDF for block storage, the first frame of the block snapshot will incorporate the VDF proof output from the master pulse clock at time of initiation. Subsequent iterations of the VDF will incorporate the previous iteration\u2019s output as a selection modulo block chunk size, choosing a Merkle proof of the block to input as the next iteration."}),(0,s.jsx)("p",{className:"pb-4 text-justify",children:"To form a bond between data pulses and the master pulse clock, at the end of each hour, the polynomial commitments of the current state of the data block are broadcast \u2013 the subsequent hour admits time for gossip to be collected from all nodes, and is then merged into the inputs of the master pulse clock. This weaving pattern enables global state reconciliation, however individual clusters will always remain up to date (or participants will lose their reward)."})]})}),n={sidebar_position:1},l="VDFs",c={id:"learn/block-storage/vdfs",title:"VDFs",description:"",source:"@site/docs/learn/block-storage/vdfs.md",sourceDirName:"learn/block-storage",slug:"/learn/block-storage/vdfs",permalink:"/docs/learn/block-storage/vdfs",draft:!1,unlisted:!1,editUrl:"https://github.com/QuilibriumNetwork/docs/tree/main/docs/learn/block-storage/vdfs.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learn",previous:{title:"Foundations: Block Storage",permalink:"/docs/learn/block-storage/"},next:{title:"Bloom Clock",permalink:"/docs/learn/block-storage/bloom-clock"}},h={},d=[];function u(e){const t={h1:"h1",header:"header",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"vdfs",children:"VDFs"})}),"\n",(0,s.jsx)(r,{})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>n});var s=o(6540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);